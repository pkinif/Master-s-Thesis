---
output: 
  pdf_document 
---




```{r echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'asis'}

################################################
############## Package loading #################
################################################

rm(list=ls()) #Removes all items in the R environment
if (!require("plm")) install.packages("plm")
library(plm) 
if (!require("dplyr")) install.packages("dplyr")
library(dplyr) 
if (!require("data.table")) install.packages("data.table")
library(data.table)
if (!require("stargazer")) install.packages("stargazer")
library(stargazer)
if (!require("Hmisc")) install.packages("Hmisc")
library(Hmisc)
if (!require("lattice")) install.packages("lattice")
library(lattice)
if (!require("survival")) install.packages("survival")
library(survival)
if (!require("ggplot2")) install.packages("ggplot2")
library(ggplot2)
if (!require("car")) install.packages("car")
library(car)
if (!require("ggpubr")) install.packages("ggpubr")
library(ggpubr)
if (!require("xtable")) install.packages("xtable")
library(xtable)
```

```{r echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'asis'}
# Database Loading. Here I consider the database with outliers.
DataBase <- read.csv(file = "Analysis/DataBase/DataSynchronization/Lag1.csv", header = TRUE, stringsAsFactors = FALSE)

## I create a new df called "model" which contains only variables that I need

Model <- DataBase %>% select(c(YearIndex,
                               CompaniesIndex,
                               Roa,
                               TobinsQ,
                               DebtToEquityRatio,
                               NetMargin,
                               TotalAssets,
                               GicsClassification,
                               CarbonProductivity,
                               WaterProductivity,
                               WasteProductivity,
                               SustainabilityPayLink,
                               SustainableThemedCommitment,
                               AuditScore,
                               GreenScore
                               ))

## I transform the "TotalAssets" column into FirmSize using the log of TotalAssets 
Model$TotalAssets <- log(Model$TotalAssets)

## I use the natural log for TobinsQ
Model$TobinsQ <- log(Model$TobinsQ)

## I rename some columns

Model1 <- Model %>% setnames(old = c("DebtToEquityRatio", "TotalAssets", "GicsClassification", "NetMargin", "CarbonProductivity", "WaterProductivity", "WasteProductivity", "SustainabilityPayLink", "SustainableThemedCommitment", "AuditScore"), new = c("Leverage", "FirmSize", "Industry", "Growth", "CaP", "WaP", "WastP", "SPL", "STC", "A"))

```

# Results

## Get a feel of the data

```{r echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'asis'}
################################################
######## unpaired two-samples t-test ###########
################################################

Sample1 <- Model1 %>% subset( subset = !is.na(Roa)) %>% select(Roa)
Sample2 <- Model1 %>% subset( subset = !is.na(TobinsQ)) %>% select(Roa)

IdenticalAnalyses <- round(t.test(Sample1, Sample2, alternative = "two.sided", var.equal = FALSE)$p.value, digits = 4)

```

This section gives an overview of the database. \autoref{DescriptiveStatistics} presents the main descriptive statistics of each variables. The sample size of Roa (i.e. N = `r sum(!is.na(Model1$Roa))`) is superior to the sample size of TobinsQ (i.e. N = `r sum(!is.na(Model1$TobinsQ))`). Indeed, compared to ROA, calculating Tobin’s Q requires a relatively high number of financial variables and is more susceptible to missing values. This creates a disparity among the number of observations for each dependent variables. @Delmas2015 encountered the same issue and conducted an identical analysis to check whether this introduces sample bias. I did the same and the p-value of the unpaired two-samples t-test equals `r IdenticalAnalyses` meaning that they is not significant difference between both samples.

\autoref{Matrix} contains the matrix of correlation of my database. There are statistically significant correlations between outcome-based CEP variables (i.e. carbon, water and waste productivity) suggesting that my model could suffer from multicollinearity. \autoref{VIF} reports the variance inflation factor (i.e. VIF) of all the variables. The maximum VIF is 2,477 meaning that there is no multicollinearity in the model [@Obrien2007].

The R scipt of this section *Results* is available in : [Appendix B : Results - R script]. 

```{r echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'asis'}
################################################
########### Descriptive statistics #############
################################################

# I remove the column "GreenScore", "CompaniesIndex" and "YearIndex". Right now I do not need it.
Model2 <- Model1 %>% select(-c(GreenScore, YearIndex, CompaniesIndex))

# I use stargazer to create a table containing descriptive statistics for each variable

stargazer(Model2, title = "Descriptive statistics", label = "DescriptiveStatistics", header = FALSE, type = "latex", align = FALSE, table.placement = "b", digits = 2, digits.extra = 2)

```

```{r echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'asis'}
################################################
########### Matrix of correlation ##############
################################################

# The corstars function allows to create the matrix of correlation. This function contains 4 arguments: a dataframe, the method to use, the visual appearance of the matrix (i.e. if you prefer to keep the upper or lower triangle of the matrix and lasly the type of the output (i.e. "none", "html" or "latex"))

corstars <-function(x, method=c("pearson", "spearman"), removeTriangle=c("upper", "lower"), result=c("none", "html", "latex")){
  
    #Compute correlation matrix
    require(Hmisc)
    x <- as.matrix(x)
    correlation_matrix<-rcorr(x, type=method[1])
    R <- correlation_matrix$r # Matrix of correlation coeficients
    p <- correlation_matrix$P # Matrix of p-value 
    
    ## Define notions for significance levels; spacing is important.
    mystars <- ifelse(p < .01, "*** ", ifelse(p < .05, "**  ", ifelse(p < .1, "*   ", "    ")))
    
    ## trunctuate the correlation matrix to two decimal
    R <- format(round(cbind(rep(-1.11, ncol(x)), R), 2))[,-1]
    
    ## build a new matrix that includes the correlations with their apropriate stars
    Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x))
    diag(Rnew) <- paste(diag(R), " ", sep="")
    rownames(Rnew) <- colnames(x)
    colnames(Rnew) <- paste(colnames(x), "", sep="")
    
    ## remove upper triangle of correlation matrix
    if(removeTriangle[1]=="upper"){
      Rnew <- as.matrix(Rnew)
      Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
      Rnew <- as.data.frame(Rnew)
    }
    
    ## remove lower triangle of correlation matrix
    else if(removeTriangle[1]=="lower"){
      Rnew <- as.matrix(Rnew)
      Rnew[lower.tri(Rnew, diag = TRUE)] <- ""
      Rnew <- as.data.frame(Rnew)
    }
    
    ## remove last column and return the correlation matrix
    Rnew <- cbind(Rnew[1:length(Rnew)-1])
    if (result[1]=="none") return(Rnew)
    else{
      if(result[1]=="html") print(xtable(Rnew), type="html")
      else print(xtable(Rnew), type="latex") 
    }
} 

# I use the function on my database (i.e. Model2)

CorMatrix <- corstars(Model2, method = "pearson", removeTriangle = "upper",  result = "none")

# Right now, the names of each variable stand in both the names of the row and the column. I do not need to have dupplicates. So I keep the names of the variables as names of the row and I use a number for the names of the column.

number <- c( 1 : (ncol(Model2) - 1)) #number of variables
colnames(CorMatrix) <- number
NewRowNames <- paste(c( 1 : ncol(Model2)), rownames(CorMatrix), sep = ". ")
rownames(CorMatrix) <- NewRowNames

# I use stargazer to make a nice table

table <- stargazer(CorMatrix, summary = FALSE, type = "latex", title = "Correlation Matrix" , label = "Matrix", float=TRUE, float.env = "sidewaystable", header = FALSE, table.placement = "h", column.sep.width = "2pt", font.size = "small", notes = "Note : * p<0.1; ** p<0.05; *** p<0.01", notes.align = "r", align = TRUE)

```

```{r echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'asis'}
################################################
######### Variance Inflation Factor  ###########
################################################

# I make Model1 a plm database

Model1 <- pdata.frame(Model1, index = c("CompaniesIndex", "YearIndex"))


# The vif function can not be used with within model. I need to estimate my models with the pooling model.
Roa <- plm(Roa ~ SPL + STC + A + CaP + WaP + WastP + Leverage + Growth + FirmSize + Industry, model = "pooling", data = Model1, index = c("YearIndex", "CompaniesIndex"))

TobinsQ <- plm(TobinsQ ~ SPL + STC + A + CaP + WaP + WastP + Leverage + Growth + FirmSize + Industry, model = "pooling", data = Model1, index = c("YearIndex", "CompaniesIndex"))


#VIF Calculation and summary in a nice stargazer table

VifRoa <- car::vif(Roa)
VifTobin <- car::vif(TobinsQ)


VifTable <- cbind(VifRoa, VifTobin)
colnames(VifTable) <- c("Roa", "Tobin's Q")



stargazer(VifTable, summary = FALSE, title = "Variance Inflation Factor", label = "VIF", header = FALSE, type = "latex", align = TRUE, table.placement = "!", digits = 3)
```


## Outliers treatment

@Lyu2015 defines outliers as observations in the dataset that appear to be unusual and discordant and which could lead to inconsistent results. @Osborne2004 have shown that even a small proportion of outliers can significantly affect simple analyses (i.e. t-tests, correlations and ANOVAs). Outliers are an issue only and only if they are influential \footnote{Influential obervations are observations whose  removal causes a different conclusion in the analysis} [@Cousineau2010]. I have used the Cook's distance [@Cook1977] test which is a common statistical tool to assess the influence of outliers [@JPStevens1984, @Cousineau2010, @Zuurprotocoldataexploration2010]. Cook’s Distance observes the difference between the regression paramater of a given model,  \(\hat{\beta}\) and what they become if the \(i_{th}\) data points is deleted, let's say  \(\hat{\beta}_{i}\). One difficulty with treatment of outliers is that the literature have not found common theoretical framework yet for the treatment of influential outliers [@OrrJohn1991, @Cousineau2010]. @Tabachnick2007 argues that the imputation with the mean is the best method while @Cousineau2010 highlight that it tends to reduce the spread of the population, making the observed distribution more leptokurtic, and possibly increase the likelihood of a type-I error. @Dang2009 argue that more elaborate technique involves replacing outliers with possible values while @Barnett1994 would prefer to remove or windsorized them. Alternatively, @Pollet2017 propose an other route to handle outliers and argue that inclusion or exclusion of outliers depend on the significativity of the results, meaning that if results are more significant without outliers, scholars should remove them and vice versa. Following the mindset of @Pollet2017, I have removed outliers from my database. See [Appendix C : Outliers treatment]  for furthers details.



## The impact of process-based CEP on outcome-based CEP

\autoref{CepResults} reports the main results of the analysis of the impact of process-based CEP (i.e. sustainability pay link, sustainable themed commitment and audit score) on outcome-based CEP (i.e. carbon, water and waste productivity). Estimators of the three models had been estimated with the *fixed effects estimation*. Indeed, based on the p-value of the F test, the three models have FE model making both the random effects and pooled ols estimators biased.

Except for Model 1 which indicates no significant relation between sustainability pay link and carbon productivity, all models show evidences of a positive and highly statistically significant
effect of process-based CEP variables on outcome-based CEP. Consequently, hypothesis 1 is verified.

```{r echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'asis'}
################################################
######## Process vs outcome based CEP ##########
################################################

# I select only CEP variables in model2. As Model2 is already a pdata.frame, I do not need to reproduce this function on Model3.

Model3 <- Model1 %>% 
  select(c(YearIndex,
           CompaniesIndex,
           CaP, 
           WaP, 
           WastP, 
           SPL,
           STC,
           A)) 


# I test for Random Effect Model using the Lagrange Multiplier Tests for Panel Models. 

## Pooling Model
  CarbonPooling <- plm(CaP ~ SPL + STC + A, data = Model3, model="pooling")

  WaterPooling <- plm(WaP ~ SPL + STC + A, data = Model3, model="pooling")

  WastePooling <- plm(WastP ~ SPL + STC + A, data = Model3, model="pooling")

  ## Plmtest
  PlmtestCarbon <- as.numeric(round(plmtest(CarbonPooling, effect = "time", type = "bp")$p.value, digits = 3))
  PlmtestWater <- as.numeric(round(plmtest(WaterPooling, effect = "time", type = "bp")$p.value, digits = 3))
  PlmtestWaste <- as.numeric(round(plmtest(WastePooling, effect = "time", type = "bp")$p.value, digits = 3))

  ## Improve p-value understanding
  PlmtestCarbon<-ifelse(PlmtestCarbon<0.01, paste(PlmtestCarbon,"***",sep = ""),
		ifelse(PlmtestCarbon<0.05,paste(PlmtestCarbon,"**",sep = ""),
		ifelse(PlmtestCarbon<0.1,paste(PlmtestCarbon,"*",sep = ""),PlmtestCarbon)))
  PlmtestWater<-ifelse(PlmtestWater<0.01, paste(PlmtestWater,"***",sep = ""),
		ifelse(PlmtestWater<0.05,paste(PlmtestWater,"**",sep = ""),
		ifelse(PlmtestWater<0.1,paste(PlmtestWater,"*",sep = ""),PlmtestWater)))
  PlmtestWaste<-ifelse(PlmtestWaste<0.01, paste(PlmtestWaste,"***",sep = ""),
		ifelse(PlmtestWaste<0.05,paste(PlmtestWaste,"**",sep = ""),
		ifelse(PlmtestWaste<0.1,paste(PlmtestWaste,"*",sep = ""),PlmtestWaste)))
  
  
# I test for Fixed Effect Model using pFtest which is a test of individual and/or time effects based on the comparison of the within and the pooling model.
  
  ## Within Model with time effect
  
  CarbonWithin <- plm(CaP ~ SPL + STC + A, data = Model3, model="within", effect = "time")

  WaterWithin <- plm(WaP ~ SPL + STC + A, data = Model3, model="within", effect = "time")

  WasteWithin <- plm(WastP ~ SPL + STC + A, data = Model3, model="within", effect = "time")
  
  ## pFtest
  
  pFtestCarbon <- as.numeric(round(pFtest(CarbonWithin, CarbonPooling)$p.value, digits = 3))
  
  pFtestWater <- as.numeric(round(pFtest(WaterWithin, WaterPooling)$p.value, digits = 3))
  
  pFtestWaste <- as.numeric(round(pFtest(WasteWithin, WastePooling)$p.value, digits = 3))
  
  ## Improve p-value understanding
  pFtestCarbon<-ifelse(pFtestCarbon<0.01, paste(pFtestCarbon,"***",sep = ""),
		ifelse(pFtestCarbon<0.05,paste(pFtestCarbon,"**",sep = ""),
		ifelse(pFtestCarbon<0.1,paste(pFtestCarbon,"*",sep = ""),pFtestCarbon)))
  pFtestWater<-ifelse(pFtestWater<0.01, paste(pFtestWater,"***",sep = ""),
		ifelse(pFtestWater<0.05,paste(pFtestWater,"**",sep = ""),
		ifelse(pFtestWater<0.1,paste(pFtestWater,"*",sep = ""),pFtestWater)))
  pFtestWaste<-ifelse(pFtestWaste<0.01, paste(pFtestWaste,"***",sep = ""),
		ifelse(pFtestWaste<0.05,paste(pFtestWaste,"**",sep = ""),
		ifelse(pFtestWaste<0.1,paste(pFtestWaste,"*",sep = ""),pFtestWaste)))


# Based on the results of the tests, the three models need to be estimated with the fixed effects estimations (i.e. model = "within" in plm). Let's consolidate into a stargazer table
  
stargazer(CarbonWithin, WaterWithin, WasteWithin, title = "The impact of process-based on outcome-based CEP", label = "CepResults", header = FALSE, type = "latex", align = FALSE, model.numbers = FALSE, table.placement = "!", add.lines = list(c("BPLM test (pvalue)", PlmtestCarbon, PlmtestWater, PlmtestWaste),
                           c("F test (pvalue)", pFtestCarbon ,pFtestWater, pFtestWaste)))

```

## The impact of CEP on CFP 

\autoref{Lag1} reports the main results of the analysis of the impact of both process-based CEP (i.e. sustainability pay link, sustainable themed commitment and audit score) and outcome-based CEP (i.e. carbon, water and waste productivity) on short-term CFP (i.e. Roa) and long-term CFP (i.e. TobinsQ). Based on the results of BPLM and F tests, estimators of the TobinsQ model had been estimated with the *pooled ols estimation* and the estimators of the Roa model with the *fixed effects estimation*. 

TobinsQ model shows evidences of a positive and highly statistically significant effect of sustainability pay link, audit score and water productivity on long-term CEP. Roa model shows evidences of a positive and highly statistically significant effect of sustainability pay link, sustainable themed commitment and carbon productivity on short-term CEP. Consequently hypothesis 2, 3, 4 and 5 are verified.


```{r echo = FALSE, message = FALSE, error = FALSE, warning = FALSE, results = 'asis'}
################################################
######## The impact of CEP on CFP ##############
################################################

# I have already removed outliers from both model (i.e. Roa and TobinsQ) through the file = "Analysis/MakeFile_RemoveOutliers_Lag1.rmd". Consequently I just need to download them in this file.
RoaNoOut <- read.csv(file = "Analysis/DataBase/DataSynchronization/NoOutliersLag1/Roa.csv", header = TRUE, stringsAsFactors = FALSE)

TobinNoOut <- read.csv(file = "Analysis/DataBase/DataSynchronization/NoOutliersLag1/TobinsQ.csv", header = TRUE, stringsAsFactors = FALSE)

# I change names
RoaNoOut <- RoaNoOut %>% setnames(old = c("FinancialLeverage","CarbonProductivity", "WaterProductivity", "WasteProductivity", "SustainabilityPayLink", "SustainableThemedCommitment", "AuditScore"), new = c("Leverage", "CaP", "WaP", "WastP", "SPL", "STC", "A"))
TobinNoOut <- TobinNoOut %>% setnames(old = c("FinancialLeverage","CarbonProductivity", "WaterProductivity", "WasteProductivity", "SustainabilityPayLink", "SustainableThemedCommitment", "AuditScore"), new = c("Leverage", "CaP", "WaP", "WastP", "SPL", "STC", "A"))
 
# I make both df a plm dataframe
RoaNoOut <- RoaNoOut %>% pdata.frame(index = c("CompaniesIndex", "YearIndex"))
TobinNoOut <- TobinNoOut %>% pdata.frame(index = c("CompaniesIndex", "YearIndex"))

# I test for Random Effect Model using the Lagrange Multiplier Tests for Panel Models. 

  ## Pooling Model
  RoaPooling <- plm(Roa ~ SPL + STC + A + CaP + WaP + WastP + FirmSize + Leverage + Growth + Industry, data = RoaNoOut, model="pooling")
  TobinPooling <- plm(TobinsQ ~ SPL + STC + A + CaP + WaP + WastP + FirmSize + Leverage + Growth + Industry, data = TobinNoOut, model="pooling")


  ## Plmtest
  PlmtestRoa <-as.numeric(round(plmtest(RoaPooling, effect = "time", type = "bp")$p.value, digits = 3))
  PlmtestTobin <-as.numeric(round(plmtest(TobinPooling, effect = "time", type = "bp")$p.value, digits = 3))

  ## Improve p-value understanding
  PlmtestRoa<-ifelse(PlmtestRoa<0.01, paste(PlmtestRoa,"***",sep = ""),
		ifelse(PlmtestRoa<0.05,paste(PlmtestRoa,"**",sep = ""),
		ifelse(PlmtestRoa<0.1,paste(PlmtestRoa,"*",sep = ""),PlmtestRoa)))
  PlmtestTobin<-ifelse(PlmtestTobin<0.01, paste(PlmtestTobin,"***",sep = ""),
		ifelse(PlmtestTobin<0.05,paste(PlmtestTobin,"**",sep = ""),
		ifelse(PlmtestTobin<0.1,paste(PlmtestTobin,"*",sep = ""),PlmtestTobin)))
  
# I test for Fixed Effect Model using pFtest which is a test of individual and/or time effects based on the comparison of the within and the pooling model.
  
  ## Within Model with time effect
  
  RoaWithin <- plm(Roa ~ SPL + STC + A + CaP + WaP + WastP + FirmSize + Leverage + Growth + Industry, data = RoaNoOut, model="within", effect = "time")
  TobinWithin <- plm(TobinsQ ~ SPL + STC + A + CaP + WaP + WastP + FirmSize + Leverage + Growth + Industry, data = TobinNoOut, model = "within", effect = "time")
  
  ## pFtest
  
  pFtestRoa <- as.numeric(round(pFtest(RoaWithin, RoaPooling)$p.value, digits = 3))
  pFtestTobin <- as.numeric(round(pFtest(TobinWithin, TobinPooling)$p.value, digits = 3))

  ## Improve p-value understanding
  pFtestRoa<-ifelse(pFtestRoa<0.01, paste(pFtestRoa, "***",sep = ""),
		ifelse(pFtestRoa<0.05,paste(pFtestRoa,"**",sep = ""),
		ifelse(pFtestRoa<0.1,paste(pFtestRoa,"*",sep = ""),pFtestRoa)))
  pFtestTobin<-ifelse(pFtestTobin<0.01, paste(pFtestTobin,"***",sep = ""),
		ifelse(pFtestTobin<0.05,paste(pFtestTobin,"**",sep = ""),
		ifelse(pFtestTobin<0.1,paste(pFtestTobin,"*",sep = ""),pFtestTobin)))
  
# Based on the results of the tests, TobinsQ need to be estimated with the pooling ols estimations (i.e. model = "pooling" in plm) while Roa with the within effect estimation.. Let's consolidate into a nice stargazer table
  
stargazer(TobinPooling, RoaWithin, title = "The impact of process and outcome-based CEP on CFP (lag = 1)", label = "Lag1", header = FALSE, type = "latex", align = FALSE, model.numbers = FALSE, table.placement = "!", add.lines = list(c("BPLM test (pvalue)", PlmtestTobin, PlmtestRoa),
                           c("F test (pvalue)", pFtestTobin ,pFtestRoa)))

```



